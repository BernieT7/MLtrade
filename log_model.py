# -*- coding: utf-8 -*-
"""log_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wHJ6m7h9A5HHn1F1zNzX9B189_5jyd6G
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

training_set = pd.read_csv("training_indicators5_log.csv")
testing_set = pd.read_csv("testing_indicators5_log.csv")
y_train = training_set[["future 10t return"]].values
y_test = testing_set[["future 10t return"]].values

X_train = training_set[["order imbalance", "RSI", "macd signal", "log ADX", "obv", "mid price", "delta volume", "delta price", "open interest", "log spread", "vol"]].values
X_test = testing_set[["order imbalance", "RSI", "macd signal", "log ADX", "obv", "mid price", "delta volume", "delta price", "open interest", "log spread", "vol"]].values

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

import statsmodels.api as sm

X_train = sm.add_constant(X_train)
model = sm.OLS(y_train, X_train).fit()
X_train = np.delete(X_train, 0, axis=1)
print(model.summary())

from sklearn.decomposition import PCA

pca = PCA()
X_train = pca.fit_transform(X_train)
X_test = pca.transform(X_test)

print("explained variance ratio:", pca.explained_variance_ratio_)
print("accumulated explained variance ratio:", pca.explained_variance_ratio_.cumsum())

X_train = pd.DataFrame(X_train[:, :9])
X_test = pd.DataFrame(X_test[:, :9])
print(X_train.head())
print(X_test.head())

explained_var = pca.explained_variance_ratio_
cum_explained_var = np.cumsum(explained_var)

# --- 畫碎石圖（Scree Plot） ---
plt.figure(figsize=(8,5))
plt.plot(range(1, len(explained_var)+1), explained_var, marker='o', label='Individual explained variance')
plt.plot(range(1, len(cum_explained_var)+1), cum_explained_var, marker='s', label='Cumulative explained variance')
plt.title('Scree Plot of Principal Components')
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.xticks(range(1, len(explained_var)+1))
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

import statsmodels.api as sm

X_train = sm.add_constant(X_train)
model = sm.OLS(y_train, X_train).fit()
X_train = np.delete(X_train, 0, axis=1)
print(model.summary())

X_test

from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

regressor.coef_

y_pred = regressor.predict(X_test)
y_pred = np.where(np.isinf(y_pred), np.mean(y_test), y_pred)
y_pred = np.where(y_pred>1, np.mean(y_test), y_pred)
y_pred = np.where(y_pred<-1, np.mean(y_test), y_pred)
np.set_printoptions(precision=5)
print(np.concatenate((y_pred.reshape(len(y_pred), 1), y_test.reshape(len(y_test), 1)), axis=1))

y_pred = np.expm1(y_pred)
y_pred

import yfinance as yf

ticker = "^TNX"
data = yf.download(ticker, period="1y")

risk_free_rate = data['Close'].iloc[-1] / 100
risk_free_rate = risk_free_rate["^TNX"]/121

risk_free_rate

data = pd.read_csv("training_data.csv")
df = data.copy()
price_plt = df.iloc[::5, :].reset_index(drop=True)

fee = 0.0005
ATR = testing_set["ATR%"]

def backtest(TP, SL):
    position = ""
    initial_price = 0
    total_ret = []

    for i in range(len(y_pred)):
        if position == "":
            if y_pred[i] > 1*fee:
                position = "long"
                initial_price = price_plt["close"][i]

            elif y_pred[i] < -1*fee:
                position = "short"
                initial_price = price_plt["close"][i]

        elif position == "long":
            end_price = price_plt["close"][i]
            pos_return = (end_price * (1 - fee) / initial_price * (1 + fee)) - 1
            if (pos_return >= TP * ATR[i]) or (pos_return <= -SL * ATR[i]):
                position = ""
                total_ret.append(pos_return)

        elif position == "short":
            end_price = price_plt["close"][i]
            pos_return = 1 - (end_price * (1 + fee) / initial_price * (1 - fee))
            if (pos_return >= TP * ATR[i]) or (pos_return <= -SL * ATR[i]):
                position = ""
                total_ret.append(pos_return)

    if len(total_ret) == 0:
        return -np.inf

    ret = np.mean(total_ret)
    vol = np.std(total_ret)
    if vol == 0:
        return -np.inf

    sharpe = ((((1 + ret) ** 121) - 1) - risk_free_rate) / (vol * np.sqrt(121))
    return sharpe

from tqdm import tqdm  # 顯示進度條

best_SR = -np.inf
best_TP, best_SL = 0, 0

TP_range = np.arange(0.5, 3.1, 0.1)
SL_range = np.arange(0.5, 3.1, 0.1)

for TP in tqdm(TP_range, desc="Searching TP"):
    for SL in SL_range:
        SR = backtest(TP, SL)
        if SR > best_SR:
            best_SR = SR
            best_TP, best_SL = TP, SL

print(f"\nbest TP: {best_TP:.2f}\nbest SL: {best_SL:.2f}\nmax Sharpe Ratio: {best_SR:.4f}")

data = pd.read_csv("testing_data.csv")
df = data.copy()
price_plt = df.iloc[::5, :].reset_index(drop=True)

position = ""
initial_price = 0
end_price = 0
pos_return = 0
total_ret = []

long_entries = []
short_entries = []
exits = []

TP = best_TP
SL = best_SL

for i in range(len(y_pred)):
    if position == "":
        if (y_pred[i] > 1*fee):
            position = "long"
            initial_price = price_plt["close"][i]
            long_entries.append((i, initial_price))

        elif (y_pred[i] < -1*fee):
            position = "short"
            initial_price = price_plt["close"][i]
            short_entries.append((i, initial_price))

    elif position == "long":
        end_price = price_plt["close"][i]
        pos_return = (end_price * (1-fee) / initial_price * (1+fee)) - 1
        if (pos_return >= TP*ATR[i]) or (pos_return <= -SL*ATR[i]):
            position = ""
            initial_price = 0
            total_ret.append(pos_return)
            exits.append((i, end_price))

    elif position == "short":
        end_price = price_plt["close"][i]
        pos_return = 1 - (end_price  * (1+fee)/ initial_price * (1-fee))
        if (pos_return >= TP*ATR[i]) or (pos_return <= -SL*ATR[i]):
            position = ""
            initial_price = 0
            total_ret.append(pos_return)
            exits.append((i, end_price))

ret = np.mean(total_ret)
# for r in total_ret:
#     ret *= (1+r)
# ret -= 1
print("average return:", ret)

vol = np.std(total_ret)
print("standard deviation:", vol)

sharp_ratio = ((((1+ret)**121)-1)-risk_free_rate)/(vol*np.sqrt(121))
print("sharp ratio:", sharp_ratio)

# data = pd.read_csv("testing_data.csv")
# df = data.copy()
# price_plt = df.iloc[::3, :].reset_index(drop=True)

# position = ""
# initial_price = 0
# end_price = 0
# pos_return = 0
# total_ret = []

# ATR = testing_set["ATR%"]

# long_entries = []
# short_entries = []
# exits = []
# fee = 0.0005

# for i in range(len(y_pred)):
#     threshold = 1*ATR[i]
#     if position == "":
#         if (y_pred[i] > threshold and y_pred[i] > 2*fee):
#             position = "long"
#             initial_price = price_plt["close"][i]
#             long_entries.append((i, initial_price))

#         elif (y_pred[i] < -threshold and y_pred[i] < 2*fee):
#             position = "short"
#             initial_price = price_plt["close"][i]
#             short_entries.append((i, initial_price))

#     elif position == "long":
#         end_price = price_plt["close"][i]
#         pos_return = (end_price * (1-fee) / initial_price * (1+fee)) - 1
#         if (pos_return >= 1.5*threshold) or (pos_return <= -0.75*threshold):
#             position = ""
#             initial_price = 0
#             total_ret.append(pos_return)
#             exits.append((i, end_price))

#     elif position == "short":
#         end_price = price_plt["close"][i]
#         pos_return = 1 - (end_price  * (1+fee)/ initial_price * (1-fee))
#         if (pos_return >= 1.5*threshold) or (pos_return <= -0.75*threshold):
#             position = ""
#             initial_price = 0
#             total_ret.append(pos_return)
#             exits.append((i, end_price))

plt.figure(figsize=(14,7))
plt.plot(price_plt["close"], label="Price", color="blue")

plt.scatter([x[0] for x in long_entries], [x[1] for x in long_entries],
            color="green", marker="^", s=80, label="Long Entry")

plt.scatter([x[0] for x in short_entries], [x[1] for x in short_entries],
            color="red", marker="v", s=80, label="Short Entry")

plt.scatter([x[0] for x in exits], [x[1] for x in exits],
            color="black", marker="x", s=80, label="Exit")

plt.legend()
plt.title("Trading Strategy Simulation")
plt.xlabel("Index")
plt.ylabel("Price")
plt.show()

for ret in total_ret:
    print(1+ret)

print(sum(1 for ret in total_ret if ret > 0))
print(sum(1 for ret in total_ret if ret < 0))

print(sum(1 for pred in y_pred if pred > 1/2*fee))
print(sum(1 for pred in y_pred if pred < -1/2*fee))

len(y_pred)